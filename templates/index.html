<!DOCTYPE html>
<html>
<head>

  <!--Import Google Icon Font-->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      
  <!--Import materialize.css-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

  <!--Import materialize.js-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

  <!-- Vue development version, includes helpful console warnings -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  
  <!--Let browser know website is optimized for mobile-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  
  <title>Puggies</title>
  
  <style>
    body {
      background-color: #fff;
    }
    
    #app {
      text-align: center;
      margin-top: 0;
      padding: 0;
    }
    
    .dragged {
      opacity: 0.5;
    }

    .hovered {
      opacity: 0.3;
    }
    
    .drop-zone {
      padding: 0px;
      
    }
    
    .player-card {
      background-color: #876;
      color: #fff;
      height: 120px;
      margin: 0px;
      padding: 0px;
      border-radius: 10px;
    }
   
    .player-card img {
      width: 20px; 
    }
    
    .player-card.dummy {
      background-color: #eee;
      color: #000;
    }

  </style>
  
  <style>
    .responsive-component {
      height: 100px;
      background: red;
    }

    /* Applied when the component is less than 800px wide. */
    .responsive-component.small {
      background: green;
    }

    /* Applied when the component is less than 400px wide. */
    .responsive-component.tiny {
      background: blue;
    }
  </style>
  
  <script type="text/javascript">
    //https://davidwalsh.name/javascript-debounce-function
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    function debounce(func, wait, immediate, trailing) {
      var timeout;
      return function() {
        var context = this, args = arguments;
        var later = function() {
          timeout = null;
          if (trailing) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    };

    // https://github.com/Kelin2025/vue-responsive-components
    const ResponsiveMixin = {
      data() {
        return {
          el: {
            width: 0,
            height: 0,
            is: {}
          }
        }
      },
      mounted() {
        if (
          typeof process === "undefined" ||
          (!process.server && (this.breakpoints || this.$options.breakpoints))
        ) {
          this.$nextTick(() => {
            const handleResize = debounce(entries => {
              const cr = entries[0].contentRect;
              this.el.width = cr.width;
              this.el.height = cr.height;
              const conds = Object.assign(
                {},
                this.breakpoints || {},
                this.$options.breakpoints || {}
              );
              for (const breakpoint in conds) {
                this.$set(this.el.is, breakpoint, conds[breakpoint](this.el));
              }
            }, 200, true, true);

            const observer = new ResizeObserver(handleResize);
            if (this.$el instanceof Element) {
              observer.observe(this.$el);
            }
          })
        }
      }
    }

    const Responsive = {
      data() {
        return { init: false }
      },
      props: {
        noHide: { type: Boolean, default: false },
        breakpoints: { type: Object, default: undefined }
      },
      mixins: [ResponsiveMixin],
      render(h) {
        const slot =
          (this.$scopedSlots.default && this.$scopedSlots.default(this.el)) ||
          this.$slots.default;

        return !this.noHide && !this.init
          ? h(
              "div",
              {
                style: { visibility: "hidden" }
              },
              [slot]
            )
          : slot;
      },
      mounted() {
        this.init = true;
      }
    }
    Vue.component("Responsive", Responsive);

    const ResponsiveDirective = {
      inserted(el, conds) {
        if (typeof process === "undefined" || !process.server) {
          const handleResize = debounce(entries => {
            const cr = entries[0].contentRect;
            for (const breakpoint in conds.value) {
              if (conds.value[breakpoint](cr)) {
                el.classList.add(breakpoint);
              } else {
                el.classList.remove(breakpoint);
              }
            }
          }, 200, true, true);

          const observer = new ResizeObserver(handleResize);
          observer.observe(el);
        }
      }
    }
    Vue.directive("responsive", ResponsiveDirective);

    /*const VueResponsiveComponents = Vue => {
      Vue.component("Responsive", Responsive)
      Vue.directive("responsive", ResponsiveDirective)
    }*/
  </script>

  <script type="text/javascript">
  
    const bus = new Vue({
      data: {
        clientId: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
        busSource: "/lobbyupdates",
        busTarget: "/lobbyupdates"
      },
      methods: {
        send(eventName, event) {
            this.$emit(eventName, event);
            
            // send event to server
            var xhr = new XMLHttpRequest();
            xhr.open("POST", this.busTarget, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({event: eventName,
                                     sourceID: this.clientId,
                                     data: event }));
            //TODO: Add additional authentication so attacker can't just spoof
            //      messages to server with known clientID
        },
        
        processMessage(msg) {
          const msgdata = JSON.parse(msg);
          if (msgdata.sourceID == this.clientId) {
          } else {
            this.$emit(msgdata.event, msgdata.data);
          }
        }
      },
      
      created() {
        var eventSource = new EventSource(this.busSource)
        eventSource.onmessage = function(e) {
          // TODO: Check message source
          //        Sanitize data
          bus.processMessage(e.data);
        };
      }
      
    });

    window.addEventListener('load', function () {
      var app = new Vue({
        el: "#app",
        data: {
          players: %% lobbyPlayers|tojson|safe %%,
          teams: ["red", "blue"],
          roles: ["tank", "damage", "support"],
        },
        
        methods: {
          movePlayer(evt) {
            // TODO: Change this to use literals rather than raw event
            const playerID = evt.sourceID;//evt.dataTransfer.getData("playerID");
            const player = this.players.find((player) => player.id == playerID);
            const location = evt.targetGroup; //dataTransfer.getData("targetName");
            player.group = location;
          },
          
          swapPlayer(evt) {
            // TODO: Change this to use literals rather than raw event
            const playerID = evt.sourceID;//evt.dataTransfer.getData("playerID");
            const player = this.players.find((player) => player.id == playerID);
            
            const targetID = evt.targetID;//dataTransfer.getData("targetID");
            const targplayer = this.players.find((player) => player.id == targetID);
            
            const group1 = player.group;
            player.group = targplayer.group;
            targplayer.group = group1;
          }
          
        },

        created() {
          bus.$on('move-player', (evt) => { this.movePlayer(evt); });
          bus.$on('swap-player', (evt) => { this.swapPlayer(evt); });
        }
      });
    });
    
    Vue.component('player-card', {
      props: {
        player: { type: Object, required: true },
        role: {}
       },
      
      data() {
	      return {
          isDragged: false,
          isHovered: false
        }
      },
      
      computed: {
        roles() {
          if (Array.isArray(this.role)) {
            return this.role;
          } else if (Object.prototype.toString.call(this.role) === '[object String]') {
            return [ this.role ];
          } else {
            return [ "tank", "damage", "support" ];
          }
        }
      },
      
      mixins: [ResponsiveMixin],
      
      breakpoints: {
        tiny: el => el.width < 200,
        small: el => el.width < 400,
        medium: el => el.width < 600
      },

      methods: {
        startDrag(evt, player) {
          evt.dataTransfer.dropEffect = "move";
          evt.dataTransfer.effectAllowed = "move";
          evt.dataTransfer.setData("playerID", player.id);

          this.isDragged = true;
        },
        endDrag() { this.isDragged = false; },
        enterDrag(evt) { this.isHovered = true; evt.stopPropagation(); },
        exitDrag(evt) { this.isHovered = false; evt.stopPropagation(); },
        onDrop(evt, player) {
          evt.preventDefault();
          this.isHovered = false;

          // TODO: actually check if dropped item is a player
          const sourceID = evt.dataTransfer.getData("playerID"); 
          bus.send('swap-player', { sourceID: sourceID, targetID: player.id });
          evt.stopPropagation();
        },
      },
        
      template: `
        <div
          :class="['card-panel',
                   'hoverable',
                   'player-card',
                   {dragged: isDragged},
                   {hovered: isHovered},
                   {small: el.is.small}]"
          draggable
          @dragstart="startDrag($event, player)"
          @dragend="endDrag()"
          @dragenter="enterDrag($event)"
          @dragexit="exitDrag($event)"
          @drop="onDrop($event, player)"
          @dragover.prevent>
          
          <div class="row">
            <div class="col m12"> {{ el.width }} {{ player.profileData.tag }}{{ player.title }} </div>
            
            <table class="col m10 offset-m1" style="table-layout : fixed;">
              <td v-for="roled in roles" class="center-align hoverable z-depth-1">
                  <img class="responsive-img" :src="'/media/roles/' + roled + '.png'" style="float: left;" />
                  {{ player.profileData.overview[roled].sr }}
                  <br />
                  {{ player.profileData.overview[roled].peakSr }}
              </td>
            </table>
          </div>
        </div> `
    })
    
    
    Vue.component('player-group', {
      props: {
        groupId: { type: String, required: true },
        name: { type: String, default: function () { return this.groupId; } }, // Bit of a hack...
        players: { type: Array, required: true },
        role: { },
        maxPlayers: { type: Number, default: 0 }
      },

      data() {
	      return {
          isHovered: false
        }
      },
      
      computed: {
        playerGroup() {
          //Not sure if we should pass all players, or just that group
          return this.players.filter((player) => player.group === this.groupId);
        },
        emptySlots() { return this.maxPlayers ? this.maxPlayers - this.playerGroup.length : 1; }
      },
          
      methods: {
        enterDrag() { this.isHovered = true; },
        exitDrag() { this.isHovered = false; },
        onDrop(evt) {
          evt.preventDefault();
          this.isHovered = false;

          // TODO: actually check if dropped item is a player
          // And make fired event a bit nicer... 
          if ((this.maxPlayers == 0) || (this.emptySlots > 0)) {
            //evt.targetName = this.groupId; // setData doesn't work with drop.....
            //bus.send('move-player', evt)
            const sourceID = evt.dataTransfer.getData("playerID"); 
            bus.send('move-player', { sourceID: sourceID, targetGroup: this.groupId });
            evt.stopPropagation(); // prevent event being caught by container
          } else {
             // TODO: replace with bus err
             console.log("ERR: Position already full", );
          }
        },
      },
      
      template: `
      <div
        :class="['drop-zone', {hovered: isHovered}]"
        @dragenter="enterDrag()"
        @dragexit="exitDrag()"
        @drop="onDrop($event)"
        @dragover.prevent>
        <player-card
          v-for="playerd in playerGroup"
          :key="playerd.title"
          :player="playerd"
          :role="role"
          @dragenter="exitDrag()"
          @dragexit="enterDrag()">
        </player-card>

        <div class="card-panel player-card dummy" v-if="maxPlayers" v-for="n in emptySlots"> {{ name }} {{n}} </div>
        <div class="card-panel player-card dummy" v-else> ... {{ name }} ... </div>
      </div>
      `
    })
  </script>
  
</head>

<body>

  <div class = "row center"><img class="col m1" src="media/icon.jpg" /></div>
  
  <div id="app" class = "row center">
      <div class="col m3">
        <player-group group-id="waiting" :players="players" ></player-group>
      </div>
      
      <div v-for="team in teams" class="col m3" :class="'team-'+team" >
         {{ team }}
         <player-group v-for="role in roles" :group-id="team+'.'+role" :team="team" :role="role" :players="players" :max-players="2"></player-group>
      </div>

    </div>
  </div>

</body>
</html>